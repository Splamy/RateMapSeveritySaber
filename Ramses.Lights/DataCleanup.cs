using RateMapSeveritySaber;
using System.Text.Json;
using System.Text.Json.Nodes;

namespace Ramses.Lights;
public class DataCleanup
{
	private static int processed = 0;

	private static readonly JsonSerializerOptions JsonSerializerOptions = new()
	{
		WriteIndented = false
	};

	public static void Run(DirectoryInfo mapsDir)
	{
		List<DirectoryInfo> toDelete = [];
		var selectList = new SelectList();

		var mapDirectories = mapsDir.EnumerateDirectories().ToArray();

		Parallel.ForEach(mapDirectories, dir =>
		{
			Interlocked.Increment(ref processed);
			if (processed % 100 == 0)
			{
				Console.WriteLine("Processed {0}/{1}", processed, mapDirectories.Length);
			}

			var song = BSMapIO.ReadInfo(dir.FullName);

			if (song is null)
			{
				Console.WriteLine("Unable to read Deleting {0}", dir.Name);
				toDelete.Add(dir);
				return;
			}

			//if (song.CustomData?["_editors"]?.AsObject().Select(x => x.Key).Any(x => string.Equals(x, "beatsage", StringComparison.OrdinalIgnoreCase)) == true)
			//{
			//	Console.WriteLine("Autogenerated map detected! Deleting {0}", dir.Name);
			//	toDelete.Add(dir);
			//	return;
			//}

			var maps = song.DifficultyBeatmapSets
				.SelectMany(x => x.DifficultyBeatmaps)
				.Select(x => Path.Join(dir.FullName, x.BeatmapFilename))
				.ToArray();

			List<MapData> mapsJson = [];

			foreach (var map in maps)
			{
				try
				{
					using var file = File.OpenRead(map);
					var json = JsonSerializer.Deserialize<JsonObject>(file)!;
					var data = new MapData(map, json);
					var versionStr = data.Json["_version"]?.GetValue<string>() ?? data.Json["version"]?.GetValue<string>();
					if (versionStr is null || versionStr.StartsWith("1.") || versionStr.StartsWith("0."))
					{
						data.Version = 1;
					}
					else if (versionStr.StartsWith("2."))
					{
						data.Version = 2;
					}
					else if (versionStr.StartsWith("3."))
					{
						data.Version = 3;
					}
					else
					{
						throw new Exception("Unknown version");
					}
					mapsJson.Add(data);
				}
				catch (Exception e)
				{
					Console.WriteLine("Error reading {0}: {1}", map, e.Message);
				}
			}

			if (mapsJson.Count == 0)
			{
				Console.WriteLine("No readable maps detected! Deleting {0}", dir.Name);
				toDelete.Add(dir);
				return;
			}

			foreach (var map in mapsJson)
			{
				if (map.Json["_events"] is not JsonArray eventsArr)
				{
					continue;
				}

				map.Events = eventsArr;
			}

			if (mapsJson.All(x => x.Version is 1 or 2) && mapsJson.All(x => x.Events is null))
			{
				Console.WriteLine("No lights detected! Deleting {0}", dir.Name);
				toDelete.Add(dir);
				return;
			}

			// remove v3 maps
			mapsJson.RemoveAll(x => x.Version is 3);

			if (mapsJson.Count == 0)
			{
				Console.WriteLine("(1) No v2 maps detected! Skipping {0}", dir.Name);
				return;
			}

			mapsJson.RemoveAll(x => x.Events is not { Count: > 0 });

			if (mapsJson.Count == 0)
			{
				Console.WriteLine("(2) No maps with events detected! Skipping {0}", dir.Name);
				return;
			}

			var mapLightHash = new HashSet<string>();
			foreach (var map in mapsJson)
			{
				var hash = map.Events!.ToJsonString(JsonSerializerOptions);

				if (!mapLightHash.Add(hash))
				{
					continue;
				}

				selectList.Maps.Add(new SelectMap { Path = map.File });
			}
		});

		Console.WriteLine("Press enter to delete {0} maps", toDelete.Count);
		//Console.ReadLine();

		foreach (var dir in toDelete)
		{
			dir.Delete(true);
		}

		Console.WriteLine("Done!");

		using var file = File.Open("F:/Ramses/select.v2.json", FileMode.Create, FileAccess.Write, FileShare.None);
		JsonSerializer.Serialize(file, selectList);
	}
}

public class MapData
{
	public string File { get; set; }
	public int Version { get; set; }
	public JsonObject Json { get; set; }

	public JsonArray Events { get; set; }

	public MapData(string file, JsonObject json)
	{
		File = file;
		Json = json;
	}
}

public class SelectList
{
	public List<SelectMap> Maps { get; set; } = [];
}

public class SelectMap
{
	public string Path { get; set; }
}
